package Model.MazeGenerator;

import Model.Entities;

import javax.imageio.ImageIO;
import javax.swing.*;

import javax.swing.JFrame;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * This class is used to generate a maze for the game.
 * It uses a recursive backtracking algorithm to generate a maze.
 * The maze is stored as a 2D array of Rooms.
 * Each Room has 4 doors, one for each cardinal direction.
 * The doors are either open or closed.
 * The maze is generated by starting at a random room and randomly opening doors until
 * all rooms have been visited.
 * The maze is then solved by starting at the start room and recursively opening doors
 * until the end room is reached.
 * The maze is then printed to the console.
 *
 * @author Jashanpreet Jandu, Kevin Nguyen, Nicholas Zhuk
 * @version 1.0
 */
public class Maze {
    static Room[][][] myMaze;
    private static int myCurrentFloor = 0;
    private static int[] myCurrentRoom = new int[]{0, 0};
    private static HashMap<String, Entities> myEntityList = new HashMap<>();

    private static int[] enemyCoords = {300, 300, 500, 500};

    public Maze(int theNumOfFloors, int theRoomWidth, int theRoomLength) {

        //TEST ENTITY DELETE LATER
        /*Entities entity = new Entities(300,300,400,500);
        addEntity(entity,0,0);
        try {
            entity.setSprite(ImageIO.read(Maze.class.getResourceAsStream("../../View/Sprites/unknown.png")));

        } catch (IOException e) {
            e.printStackTrace();
        }*/
        ///^^^ DELETE LATER

        myMaze = new Room[theNumOfFloors][theRoomWidth][theRoomLength];
        fillMaze(theNumOfFloors, theRoomWidth, theRoomLength);
        createRoom();
    }

    public void fillMaze(int theNumOfFloors, int theRoomWidth, int theRoomLength) {
        for (int i = 0; i < theNumOfFloors; i++) {
            myMaze[i] = new FloorGenerator(theRoomWidth, theRoomLength).getFloor();
        }
    }

    public Room[][] getFloor(int theFloorNum) {
        return myMaze[theFloorNum - 1];
    }

    public void goDownFloors() {
        myCurrentFloor++;
    }

    public static void drawMiniMap(Graphics2D g) {
        int mazeX = 900;
        int mazeY = 50;
        int scale = 20;
        g.setColor(Color.black);
        g.setComposite(AlphaComposite.getInstance(
                AlphaComposite.SRC_OVER, 0.5f));
        g.fillRect(mazeX, mazeY, scale * myMaze[0].length, scale * myMaze[0].length);
        g.setComposite(AlphaComposite.getInstance(
                AlphaComposite.SRC_OVER, 1.0f));
        g.setColor(Color.red);
        g.fillRect(mazeX + myCurrentRoom[0] * scale, mazeY + myCurrentRoom[1] * scale, scale, scale);
        g.setColor(Color.lightGray);
        g.setStroke(new BasicStroke(2));
        for (int i = 0; i < myMaze[myCurrentFloor].length; i++) {
            for (int j = 0; j < myMaze[myCurrentFloor][i].length; j++) {

                if (!myMaze[myCurrentFloor][j][i].isMyDoorNorth()) {
                    g.drawLine(mazeX + j * scale, mazeY + i * scale, mazeX + j * scale + scale, mazeY + i * scale);
                }
                if (!myMaze[myCurrentFloor][j][i].isMyDoorSouth()) {
                    g.drawLine(mazeX + j * scale, mazeY + i * scale + scale, mazeX + j * scale + scale, mazeY + i * scale + scale);
                }
                if (!myMaze[myCurrentFloor][j][i].isMyDoorEast()) {
                    g.drawLine(mazeX + j * scale + scale, mazeY + i * scale, mazeX + j * scale + scale, mazeY + i * scale + scale);
                }
                if (!myMaze[myCurrentFloor][j][i].isMyDoorWest()) {
                    g.drawLine(mazeX + j * scale, mazeY + i * scale, mazeX + j * scale, mazeY + i * scale + scale);
                }
            }
        }
    }

    public static void drawRoom(Graphics2D g) {
        if (myCurrentRoom[0] < 0 || myCurrentRoom[1] < 0 || myCurrentRoom[1] > 9 || myCurrentRoom[0] > 9) {
            System.out.println("Something wrong");
        }
        Room theRoom = myMaze[myCurrentFloor][myCurrentRoom[0]][myCurrentRoom[1]];
        int tilesize = 400;
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                g.drawImage(theRoom.getBackground(), j * tilesize, i * tilesize, tilesize, tilesize, null);

            }
        }

        if (!theRoom.isMyDoorNorth()) {
            theRoom.northDoorEntity().draw(g);
        }
        if (!theRoom.isMyDoorSouth()) {
            theRoom.southDoorEntity().draw(g);
        }
        if (!theRoom.isMyDoorEast()) {
            theRoom.eastDoorEntity().draw(g);
        }
        if (!theRoom.isMyDoorWest()) {
            theRoom.westDoorEntity().draw(g);
        }
        if (myEntityList.get("enemy") != null) {
            myEntityList.get("enemy").draw(g);
        }
    }

    public static void addEntity(String name, Entities entity, int RoomX, int RoomY) {
        entity.setRoomLocation(RoomX, RoomY);
        myEntityList.put(name, entity);
    }

    public static void createRoom() {
        Room theRoom = myMaze[myCurrentFloor][myCurrentRoom[0]][myCurrentRoom[1]];

        if (theRoom.getEnemy() != null) {
            String name = theRoom.getEnemy().getName();
            Entities theEnemy = new Entities(enemyCoords[0], enemyCoords[1], enemyCoords[2], enemyCoords[3], true);
            String path = "../../View/Sprites/EnemySprites/" + name + ".png";

            BufferedImage img = null;
            System.out.println(name);
            try {
                img = ImageIO.read(Maze.class.getResourceAsStream(path));

            } catch (IOException e) {
                e.printStackTrace();
            }

            theEnemy.setSprite(img);
            addEntity("enemy", theEnemy, myCurrentRoom[0], myCurrentRoom[1]);

        } else {
            myEntityList.remove("enemy");
        }

        if (!theRoom.isMyDoorNorth()) {
            theRoom.setDoors("North", "../../View/Sprites/northwall.png");
            Entities northDoor = theRoom.northDoorEntity();

            addEntity("NorthDoor", northDoor, myCurrentRoom[0], myCurrentRoom[1]);

        } else {
            myEntityList.remove("NorthDoor");
        }
        if (!theRoom.isMyDoorSouth()) {
            theRoom.setDoors("South", "../../View/Sprites/southwall.png");
            Entities southDoor = theRoom.southDoorEntity();

            addEntity("SouthDoor", southDoor, myCurrentRoom[0], myCurrentRoom[1]);
        } else {
            myEntityList.remove("SouthDoor");
        }
        if (!theRoom.isMyDoorEast()) {
            theRoom.setDoors("East", "../../View/Sprites/eastwall.png");
            Entities eastDoor = theRoom.eastDoorEntity();

            addEntity("EastDoor", eastDoor, myCurrentRoom[0], myCurrentRoom[1]);
        } else {
            myEntityList.remove("EastDoor");
        }
        if (!theRoom.isMyDoorWest()) {
            theRoom.setDoors("West", "../../View/Sprites/westwall.png");
            Entities westDoor = theRoom.westDoorEntity();

            addEntity("WestDoor", westDoor, myCurrentRoom[0], myCurrentRoom[1]);
        } else {
            myEntityList.remove("WestDoor");
        }
    }

    public static void switchRoom(Direction direction) {

        switch (direction) {
            case NORTH -> {
                myCurrentRoom[1]--;
                System.out.println("Went North");
            }
            case SOUTH -> {
                myCurrentRoom[1]++;
                System.out.println("Went South");
            }
            case WEST -> {
                myCurrentRoom[0]--;
                System.out.println("Went West");
            }
            case EAST -> {
                System.out.println("Went East");
                myCurrentRoom[0]++;
            }
        }
        System.out.println("My Room: " + myCurrentRoom[0] + " - " + myCurrentRoom[1]);
        createRoom();
    }

    public static HashMap<String, Entities> getEntityList() {
        return myEntityList;
    }

    public static void update() {
        myMaze[myCurrentFloor][myCurrentRoom[0]][myCurrentRoom[1]].update();
    }

    public enum Wall {
        NORTHWALL,
        SOUTHWALL,
        WESTWALL,
        EASTWALL
    }

    public enum Direction {
        NORTH,
        SOUTH,
        WEST,
        EAST
    }
}
